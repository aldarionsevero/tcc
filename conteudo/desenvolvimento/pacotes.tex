\section{Funcionalidade de extrair pacotes}
\label{sec:pacotes}

\subsection{Atributos}
Para a ter a funcionalidade mínima esperada desse recurso, definimos que iríamos
precisar extrair os seguintes atributos:

\begin{itemize}
  \item \textit{version}: especifica a versão do pacote;
  \item \textit{action}: define a ação que deve ser tomada
    (instalar, remover, reconfigurar, etc);
\end{itemize}

\subsection{\textit{Plugin} de Extração}

O Ohai provê um plugin nativo que coleta todos os pacotes instalados. O suporte
das plataformas são: Debian, Redhat, Fedora e OpenSUSE\@. Os dados coletados pelo
plugin de cada pacote são: nome do pacote e versão.

Para a plataforma Debian, o plugin utiliza a ferramenta \texttt{dpkg-query} disponível
por padrão nas distro Debian \textit{based}. O \texttt{dpkg-query} retorna uma lista de todos os pacotes
instalados no ambiente que é interpretada pelo plugin e transformada em um JSON
construído com a estrutura \texttt{``package\_name'' => \{ ``version'' => ``version\_number'' \}}
como mostrada no Código~\ref{code:json_pkg}.

\noindent\begin{minipage}{\textwidth}
  \lstset{style=shell}
  \lstinputlisting[frame=single,
    label=code:json_pkg,
    caption="Saída JSON do plugin Ohai \textit{packages}"]{conteudo/code/json_pkg.json}
\end{minipage}\hfill

Para as plataformas Redhat, Fedora e OpenSUSE, o plugin utiliza a ferramenta \texttt{rpm}
disponível por padrão nas distros Redhat \textit{based}. O Cupper ainda não oferece suporte
para distros Redhat \textit{based}, portanto não foram feitos testes para esse tipo de ambiente.

Não há suporte para a plataforma Arch Linux, portanto um plugin foi desenvolvido
para extrair as mesmas informações. A extração utiliza a ferramenta \texttt{pacman} disponível
nas distros Arch Linux. O \texttt{pacman} retorna uma lista de pacotes instalados no ambiente
que é interpretada pelo plugin e transformada em um JSON construído com a estrutura
\texttt{"package\_name" => \{ "version" => "version\_number" \}} como mostrada no
Código~\ref{code:json_pkg_pacman}.

\noindent\begin{minipage}{\textwidth}
  \lstset{style=shell}
  \lstinputlisting[frame=single,
    label=code:json_pkg_pacman,
    caption="Saída JSON do plugin Ohai \textit(pacman)"]{conteudo/code/json_pkg_pacman.json}
\end{minipage}\hfill

\subsection{Bloco de Receita Gerado}

O JSON gerado pela extração é utilizado para construir a receita responsável pela instalação dos
pacotes. É utilizado o recurso Chef \textit{package} para instalação com os dois atributos
\textit{version} e em \textit{action} (Código~\ref{code:pkg_recipe}). \textit{Version}
é extraído de cada pacote e \textit{action} é colocado \textit{\textit{:install}} como padrão para todos os pacotes.

\noindent\begin{minipage}{\textwidth}
  \lstset{style=shell}
  \lstinputlisting[
    language=Ruby,
    frame=single,
    label=code:pkg_recipe,
    caption="Exemplo de receita gerada pela extração de pacotes."]{conteudo/code/pkg_recipe.rb}
\end{minipage}\hfill

Considera-se que o pacote irá cuidar da suas próprias dependências quanto a instalação.
Sendo assim, os pacotes que são dependências de outros não são inclusos na receita. Exemplo, se o pacote
\textbf{A} contém as dependências \textbf{B} e \textbf{C} elas não serão inclusas na receita, pois o pacote \textbf{A} irá realizar a instalação.

\subsection{Problemas Encontrados}

\subsubsection{Pacotes com repositório fora do \textit{source list} para o 
gerenciador de pacotes}
Esse problema surgia quando um pacote que foi instalado manualmente, ou que
teve seu reposotório removido do \textit{source list} era extraído usando o Cupper,
mas ao executar a receita em um novo ambiente, a instalação falhava, já que 
o gerenciador de pacotes não encontrava a fonte do pacote.

Já que isso não é o comportamento esperado, mas pode ser uma escolha do usuário
ter pacotes de outras fontes, foi criado um atributo para que o usuário defina no
Cupperfile e decida se quer que se extraia pacotes que tem fonte em repositórios
fora do \textit{source list}. O exemplo de Cupperfile que é criado pelo comando
\textit{cupper create project} tem exemplos desses atributos e explicação, como
no Código~\ref{code:sourcelesspackages.rb}.

\noindent\begin{minipage}{0.7\textwidth}
  \lstset{style=shell}
  \lstinputlisting[language=Ruby, label=code:sourcelesspackages.rb, caption="Definição do atributo de \textit{sourceless packages}"]{conteudo/code/sourcelesspackages.rb}
\end{minipage}\hfill

\subsubsection{Pacotes já instalados no ambiete novo com versões menores}
Os pacotes já instlados no ambiente novo em que a receita vai rodar podem ter versões
maiores do que a dos pacotes extraídos do ambiente original. Se a receita for
montada sem nenhum tipo de tratamento, a sua execução vai quebrar no momento
em que ela tentar fazer esse \textit{downgrade}.

Foi criado então um atributo para o Cupperfile que deixa o usuário definir
se o Cupper vai forçar os \textit{downgrades} ou se vai ignorar os recursos
Cheff de pacotes que caírem nessa situação, passando \textit{action :nothing}
para esses. O exemplo vindo do Cupperfile com sua explicação pode ser visto no
Código~\ref{code:allowdowngrade}

\noindent\begin{minipage}{0.7\textwidth}
  \lstset{style=shell}
  \lstinputlisting[language=Ruby, label=code:allowdowngrade, caption="Definição do atributo de \textit{allow downgrade}"]{conteudo/code/allowdowngrade.rb}
\end{minipage}\hfill
